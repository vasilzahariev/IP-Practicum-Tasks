# Подготовка за първо контролно по УП

## [Линк към онлайн срещата](https://meet.google.com/mwj-jfmh-qoj)

Задачите са давани на първото контролно от курса по Увод в Програмирането на КН от 2021/2022 и са направени от доц. д-р Трифон Трифонов, доц. д-р Нора Ангелова и техния колектив.

## Задача 1

Конкатенация на две естествени числа **A** и **B** наричаме число **A ∘ B**, което се получава като към цифрите на **A** се долепят цифрите на **B**.

<ins>Пример:</ins>

123 ∘ 431 = 123431

123 ∘ 0 = 1230

Да се напише програма, която въвежда две естествени числа **N** и **К** и извежда дали съществуват естествени числа **А** и **B**, такива че **N = A ∘ K ∘ B**.

*За реализацията на задача може да се използва и функция с два параметъра – **N** и **К**. В решението на задачата не се допуска използването на масиви!*

<ins>Примери:</ins>

| Вход | Изход | Обяснение |
|------|-------|-----------|
| N = 1234</br>K = 23 | True | N = 1 ∘ K ∘ 4 |
| N = 1234</br>K = 4 | False |  |
| N = 1234</br>K = 2 | True | N = 1 ∘ K ∘ 34 |

## Задача 2

Едно число ще наричаме „съседно“, ако всеки две негови съседни цифри са различни.

<ins>Пример:</ins> 2572 е съседно, но 3119 не е.

Да се напише програма, която намира разликата на най-голямото и най-малкото „съседно“ число в интервала [**a**; **b**], където **a** и **b** са въведени от клавиатурата естествени числа. Ако в интервала няма съседни числа, да се изведе подходящо съобщение. Позволено е използването на масиви и функции.

<ins>Примери:</ins>

| Вход | Изход | Обяснение |
|------|-------|-----------|
| a = 8 </br> b = 100 | 89 | 89 = 98 - 9 |
| a = 1099 </br> b = 1222 | 18 | 18 = 1219 - 1201 |
| a = 110 </br> b = 115 | No adjecent numbers | Първите 2 цифри са равни |

## Задача 3

“Подредица” на дадена редица наричаме редица, която се получава след евентуалното изтриване на нула или повече елементи в началото и края на първоначалната редица.

<ins>Пример:</ins> редиците **abc**, **cd**, de са три подредици на редицата **abcde**.


“Ротация” на дадена редица се нарича такава подредба на елементите на редицата, която се получава като няколко елементи от края на редицата се преместят в същия ред в началото на редицата.

<ins>Пример:</ins> всички възможни ротации на редицата **abcde** са **eabcd**, **deabc**, **cdeab** и **bcdea**.

Да се напише програма, която въвежда от стандартния вход две положителни цели числа size1 и size2 и две редици от латински букви firstArr и secondArr, съответно с дължини size1 и size2. Програмата да определи дали някоя ротация на secondArr е подредица на firstArr, и ако това е така да изведе ротацията и да изведе колко символа от началото и края на firstArr трябва да се изтрият, за да се получи подредицата secondArr. Ако такава ротация няма, да се изведе подходящо съобщение.

**Ограничения:**

0 < size2 <= size1 < 1024

<ins>Примери:</ins>

| Вход | Изход |
|------|-------|
| size1: 5 </br> size2: 3 </br> firstArr: 'h', 'e', 'l', 'l', 'o' </br> secondArr: 'l', 'o', 'l' | Rotation "llo" found after deleting 2 characters from the start and 0 characters from the end |
| size1: 7 </br> size2: 4 </br> firstArr: 'g', 'o', 'o', 'd', 'b', 'y', 'e' </br> secondArr: 'b', 'o', 'd', 'y' | No rotation found |

### Бонус към задача 3

Ако програмата не намери нито една ротация, която да е подредица, да определи дали от firstArr може да се получи някоя ротация на secondArr с изтриване на символи на произволни места. Ако това е възможно, да се изведат позициите в firstArr, на които трябва да се изтрият символите и коя ротация се получава.

<ins>Примери:</ins>

| Вход | Изход |
|------|-------|
| size1: 6 </br> size2: 3 </br> firstArr: 'a', 'x', 'z', 't', 'c', 'y' </br> secondArr: 'c', 'a', 't' | Rotation "atc" found after deleting characters: 1 2 5 |
| size1: 9 </br> size2: 4 </br> firstArr: 'c', 'm', 'd', 'a', 'i', 'h', 'n', 'b', 'a' </br> secondArr: 'a', 'd', 'h', 'p' | No rotation found |
